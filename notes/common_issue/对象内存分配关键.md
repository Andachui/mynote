**分享概要：**

1. **对象分配内存难点总结**

## **一、对象分配内存难点总结**
[详细请看](https://note.youdao.com/ynoteshare1/index.html?id=8df8c92eea0b21258dab5fc84e61171f&type=notebook#/wcp1587359101197722)
---
### 分配内存选择：
类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式：  

指针碰撞：  
如果内存是规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器
，那所分配的内存就仅仅是把指针向空闲空间那边移动对象大小的距离 
空闲列表：  
如果不规则，已使用的内存和空闲的内存相互交错，那就没办法简单的进行指针碰撞了
。虚拟机必须维护一个列表来记录那些内存是可用的，在分配的时候从列表找到一块足够大的空间划分给对象实例
并更新列表的记录

选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。  


### 分配内存并发处理：
对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在
并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对
象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：
1. 对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）；
2. 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预
先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）
。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 
TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。

### 对象的访问定位：
Java程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 
JVM 虚拟机的实现。目前主流的访问方式有 句柄 和 直接指针 两种方式。

1. 指针： 指向对象，代表一个对象在内存中的起始地址。
>如果使用直接指针访问，引用 中存储的直接就是对象地址，那么Java堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。

优势：速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。

2. 句柄： 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化
，指向固定内存地址），再由对象的指针指向对象的真实内存地址。

>Java堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息

优势：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改

